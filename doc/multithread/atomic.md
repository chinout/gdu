# 原子操作

请见sdatomic.h。线程同步的一大部分都与原子访问（atomic access）。所谓原子访问，指的是一个线程在访问某个资源的同时能
够保证没有其他线程会在同一个时刻访问同一资源，也就是说，对于任何一个原子操作函数，您都可以将其当作一个完整的，不可>分割的操作。请允许我们举一个最常见的例子：

```
有一个全局对象：
volatile int g_data = 0;
第一个线程：
g_data++;
第二个线程：
g_data++;
那么，当这两个线程执行完成，最终的结果，就可能有这么几种：
1，2
很明显，我们期望的结果是2，但是，确实是可能出现1这个结果。这是因为，＋＋操作，其实可以分为两个操作，第一个是取值，>第二是加一，由于两个线程同时执行，那么当这两个线程的这两步操作交错时，则出现了1这个结果。那么，我们该如何使用原子操
作来达到正确的结果呢？

第一个线程：
SGDP::GAtomicInc32(&g_data);
第二个线程：
SGDP::GAtomicInc32(&g_data);
那么，当这两个线程执行完成，最终的结果，则一定为1。这是因为，当您使用原子操作时，UINT32 SDAPI GAtomicInc32(volatile UINT32 *mem);是被当作一步操作的。
```

目前，我们提供的原子操作包括：

* 32位原子设置
* 32位原子获取
* 32位原子加
* 32位原子加1
* 32位原子减
* 32位原子减1
* 64位原子设置
* 64位原子获取
* 64位原子加
* 64位原子加1
* 64位原子减
* 64位原子减1
